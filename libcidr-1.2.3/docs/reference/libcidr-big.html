<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">

<html lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for FreeBSD (vers 7 December 2008), see www.w3.org">

  <title>libcidr - Code Documentation</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="Generator" content="Codelibrary DTD DSSSL">
  <style type="text/css" media="all">
@import "codelibrary-html.css";
  </style>
</head>

<body>
  <div class="geninfo">
    <h1 id="geninfo">Summary</h1>

    <p>libcidr is a library to make it easier to handle IP addresses and
    blocks, and manipulate them in various ways.</p>

    <p>The core of the library is a pair of functions that take a human
    readable string and turn it into our internal representation of a CIDR
    address block (<a href="#CIDR-FROM-STR">cidr_from_str()</a> ), and one
    to take that internal representation and turn it into a human-readable
    string (<a href="#CIDR-TO-STR">cidr_to_str()</a> ). There are a large
    number of options for how to format that string, as well.</p>

    <p>Additionally, there are functions to compare different CIDR blocks,
    to determine if they're equal, or if one is contained within the
    other. This functionality can be useful for writing access-control
    code, or client-dependant configuration, or similar things. There are
    functions to manipulate address blocks and determine attributes of
    them, like network/broadcast addresses, the range of host addresses,
    the number of available host addresses, etc. There are functions to
    split a CIDR block into the two smaller blocks it contains, or to
    derive the parent block that it is itself contained within. And there
    are functions to translate to and from in_addr-type structures, which
    the operating system commonly uses to represent addresses for handle
    socket connections and so forth.</p>

    <p>In short, just about anything you might do in a program with IP
    addressing, whether referring to individual hosts, or to any sized
    subnets, libcidr is designed to simplify handling. It's not a DNS
    library, nor is it a socket abstraction layer. It's just a set of
    functions for manipulating raw IP addresses in various ways.</p>

    <p>The functions generally follow standard C conventions. They tend to
    return 0 or a pointer when acting properly, and -1 or NULL when
    something went wrong (unless the function usage suggests other
    returns, of course, as in <a href=
    "#CIDR-GET-PFLEN">cidr_get_pflen()</a> ). They set errno when
    returning an error; the error codes each function can return are
    documented with the function.</p>

    <p>libcidr doesn't use any threading itself. It should, however, be
    safe to use in any threaded program if used sensibly. Only a very few
    functions use static strings, and those that do (<a href=
    "#CIDR-VERSION">cidr_version()</a> and <a href=
    "#CIDR-NUMADDR">cidr_numaddr()</a> and its related functions being the
    only ones I can think of) tend to be constant strings as well, so they
    wouldn't be changing. Of course, you don't want to <a href=
    "#CIDR-FREE">cidr_free()</a> a <a href="#CIDR-ADDR">CIDR</a> in one
    thread while you're still using it in another, but if you do, it's not
    libcidr's fault.</p>

    <p>For the current version or any extra information, see the libcidr
    project homepage, at
    &lt;http://www.over-yonder.net/~fullermd/projects/libcidr&gt;.</p>

    <p>This reference manual is build using the codelibrary SGML DTD,
    which is specifically designed for documenting libraries. See the
    codelibrary homepage at
    &lt;http://www.over-yonder.net/~fullermd/projects/sgml/codelibrary&gt;
    for more details on it.</p>
  </div>

  <div class="contents">
    <h1>Contents</h1>

    <h2><a href="#datastructs">Data structures:</a></h2>

    <ul>
      <li class="listlist"><a href="#CIDR-ADDR">CIDR</a>
      <em>(Internal)</em></li>
    </ul>

    <h2><a href="#functions">Functions:</a></h2>

    <ul>
      <li class="listlist"><a href=
      "#CIDR-ADDR-BROADCAST">cidr_addr_broadcast()</a></li>

      <li class="listlist"><a href=
      "#CIDR-ADDR-HOSTMAX">cidr_addr_hostmax()</a></li>

      <li class="listlist"><a href=
      "#CIDR-ADDR-HOSTMIN">cidr_addr_hostmin()</a></li>

      <li class="listlist"><a href=
      "#CIDR-ADDR-NETWORK">cidr_addr_network()</a></li>

      <li class="listlist"><a href="#CIDR-ALLOC">cidr_alloc()</a></li>

      <li class="listlist"><a href=
      "#CIDR-CONTAINS">cidr_contains()</a></li>

      <li class="listlist"><a href="#CIDR-DUP">cidr_dup()</a></li>

      <li class="listlist"><a href="#CIDR-EQUALS">cidr_equals()</a></li>

      <li class="listlist"><a href="#CIDR-FREE">cidr_free()</a></li>

      <li class="listlist"><a href=
      "#CIDR-FROM-INADDR">cidr_from_inaddr()</a></li>

      <li class="listlist"><a href=
      "#CIDR-FROM-IN6ADDR">cidr_from_in6addr()</a></li>

      <li class="listlist"><a href=
      "#CIDR-FROM-STR">cidr_from_str()</a></li>

      <li class="listlist"><a href=
      "#CIDR-GET-ADDR">cidr_get_addr()</a></li>

      <li class="listlist"><a href=
      "#CIDR-GET-MASK">cidr_get_mask()</a></li>

      <li class="listlist"><a href=
      "#CIDR-GET-PFLEN">cidr_get_pflen()</a></li>

      <li class="listlist"><a href=
      "#CIDR-GET-PROTO">cidr_get_proto()</a></li>

      <li class="listlist"><a href=
      "#CIDR-IS-V4MAPPED">cidr_is_v4mapped()</a></li>

      <li class="listlist"><a href=
      "#CIDR-NET-SUBNETS">cidr_net_subnets()</a></li>

      <li class="listlist"><a href=
      "#CIDR-NET-SUPERNET">cidr_net_supernet()</a></li>

      <li class="listlist"><a href="#CIDR-NUMADDR">cidr_numaddr()</a></li>

      <li class="listlist"><a href=
      "#CIDR-NUMADDR-PFLEN">cidr_numaddr_pflen()</a></li>

      <li class="listlist"><a href="#CIDR-NUMHOST">cidr_numhost()</a></li>

      <li class="listlist"><a href=
      "#CIDR-NUMHOST-PFLEN">cidr_numhost_pflen()</a></li>

      <li class="listlist"><a href=
      "#CIDR-TO-INADDR">cidr_to_inaddr()</a></li>

      <li class="listlist"><a href=
      "#CIDR-TO-IN6ADDR">cidr_to_in6addr()</a></li>

      <li class="listlist"><a href="#CIDR-TO-STR">cidr_to_str()</a></li>

      <li class="listlist"><a href="#CIDR-VERSION">cidr_version()</a></li>
    </ul>
  </div>

  <div class="datastructs">
    <h1 id="datastructs">Data structures</h1>

    <ul>
      <li id="CIDR-ADDR">
        <span class="structdef">CIDR: A single CIDR-format IP block</span>

        <p><em class="privdata">This datatype is intended for internal use
        only</em></p>

        <ul>
          <li>
            <div class="note">
              <p>Note:</p>

              <p>Use the <a href="#CIDR-FREE">cidr_free()</a> function to
              free the memory associated with this datatype, and the
              <a href="#CIDR-ALLOC">cidr_alloc()</a> function to allocate
              and initialize the structure.</p>
            </div>
          </li>

          <li>Members:

            <ul>
              <li><span class="memberdef">int version:</span> The
              structure version. This is reserved for future use, and put
              in to hold its place at the start of the array.</li>

              <li><span class="memberdef">uint8_t addr[16]:</span> The 16
              octets that make up an IP address. For v6 addresses, all are
              used. For v4 addresses, only the last 4 are really used. The
              prior 2 octets are filled in with all-ones, so that the
              internal representation matches the v4-compat IPv6
              addressing block. This is useful when, for instance, using
              <a href="#CIDR-TO-IN6ADDR">cidr_to_in6addr()</a> , in that
              it gives you the expected result.</li>

              <li><span class="memberdef">uint8_t mask[16]:</span> The 16
              octets that make up an IP netmask. For v4 addresses, only
              the last 4 are really used; the rest are intialized to
              all-bits-one however, which is correct in spirit.</li>

              <li><span class="memberdef">int proto:</span> The protocol
              the address described is. Currently possible values are
              CIDR_IPV4 and CIDR_IPV6. I think that's pretty
              self-explanatory.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </div>

  <div class="functions">
    <h1 id="functions">Functions</h1>

    <ul>
      <li id="CIDR-ADDR-BROADCAST">
        <span class="funcdef">cidr_addr_broadcast(): Find the broadcast
        address</span>

        <ul>
          <li>Summary:

            <p>Generate a <a href="#CIDR-ADDR">CIDR</a> structure
            describing the broadcast address of the passed-in
            netblock.</p>

            <p>Note that using this with an IPv6 netblock is technically
            asking for something that doesn't exist, since IPv6 doesn't
            have subnet broadcast addresses. This function will still
            return the all-1's address though, on the assumption that if
            you're asking the question, it's the answer you want.</p>

            <p>An additional somewhat specialized case is that of an IPv4
            /31 or IPv6 /127. Depending on your interpretation and usage,
            this is either a useless subnet since it only contains network
            and broadcast and no hosts, or a subnet that holds 2 hosts
            with neither network or broadcast address (commonly used for
            point-to-point links). As a result, <a href=
            "#CIDR-ADDR-BROADCAST">cidr_addr_broadcast()</a> and <a href=
            "#CIDR-ADDR-NETWORK">cidr_addr_network()</a> will give answers
            as if it were a host-less subnet, while <a href=
            "#CIDR-ADDR-HOSTMAX">cidr_addr_hostmax()</a> and <a href=
            "#CIDR-ADDR-HOSTMIN">cidr_addr_hostmin()</a> will answer as
            though it were a 2-host subnet. It can be seen as a little
            strange for <a href=
            "#CIDR-ADDR-BROADCAST">cidr_addr_broadcast()</a> and <a href=
            "#CIDR-ADDR-HOSTMAX">cidr_addr_hostmax()</a> to give the same
            answer, but as above, libcidr assumes that if you ask the
            question, you want the answer that makes sense in that
            context.</p>

            <p>Similar caveats apply to calling these on a v4 /32 or v6
            /128. Ask a silly question, get a silly answer :)</p>

            <p>The returned structure should be cleaned up using <a href=
            "#CIDR-FREE">cidr_free()</a> .</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> A <a href="#CIDR-ADDR">CIDR</a> structure
              describing an arbitrary netblock.</li>
            </ul>
          </li>

          <li>Returns:

            <p><a href="#CIDR-ADDR">CIDR</a> *</p>

            <p>Returns a pointer to a <a href="#CIDR-ADDR">CIDR</a>
            structure describing the broadcast address on success. Returns
            NULL on failure.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Given NULL</dd>
                </dl>
              </li>

              <li>
                <div class="note">
                  <p>Note:</p>

                  <p><a href=
                  "#CIDR-ADDR-BROADCAST">cidr_addr_broadcast()</a> can
                  also fail and set errno for any of the reasons listed
                  for <a href="#CIDR-ALLOC">cidr_alloc()</a> .</p>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-ADDR-HOSTMAX">
        <span class="funcdef">cidr_addr_hostmax(): Find the highest host
        address</span>

        <ul>
          <li>Summary:

            <p>Generate a <a href="#CIDR-ADDR">CIDR</a> structure
            describing the highest-numbered address available for a host
            IP in the given netblock.</p>

            <p>See the discussion under <a href=
            "#CIDR-ADDR-BROADCAST">cidr_addr_broadcast()</a> concerning
            near- amd maximal-prefix-length blocks for edge case
            details.</p>

            <p>The returned structure should be cleaned up using <a href=
            "#CIDR-FREE">cidr_free()</a> .</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> A <a href="#CIDR-ADDR">CIDR</a> structure
              describing an arbitrary netblock.</li>
            </ul>
          </li>

          <li>Returns:

            <p><a href="#CIDR-ADDR">CIDR</a> *</p>

            <p>Returns a pointer to a <a href="#CIDR-ADDR">CIDR</a>
            structure describing the max host address on success. Returns
            NULL on failure.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <div class="note">
                  <p>Note:</p>

                  <p><a href="#CIDR-ADDR-HOSTMAX">cidr_addr_hostmax()</a>
                  can fail and set errno for any of the reasons listed for
                  <a href="#CIDR-ADDR-BROADCAST">cidr_addr_broadcast()</a>
                  .</p>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-ADDR-HOSTMIN">
        <span class="funcdef">cidr_addr_hostmin(): Find the lowest host
        address</span>

        <ul>
          <li>Summary:

            <p>Generate a <a href="#CIDR-ADDR">CIDR</a> structure
            describing the lowest-numbered address available for a host IP
            in the given netblock.</p>

            <p>See the discussion under <a href=
            "#CIDR-ADDR-BROADCAST">cidr_addr_broadcast()</a> concerning
            near- amd maximal-prefix-length blocks for edge case
            details.</p>

            <p>The returned structure should be cleaned up using <a href=
            "#CIDR-FREE">cidr_free()</a> .</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> A <a href="#CIDR-ADDR">CIDR</a> structure
              describing an arbitrary netblock.</li>
            </ul>
          </li>

          <li>Returns:

            <p><a href="#CIDR-ADDR">CIDR</a> *</p>

            <p>Returns a pointer to a <a href="#CIDR-ADDR">CIDR</a>
            structure describing the min host address on success. Returns
            NULL on failure.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <div class="note">
                  <p>Note:</p>

                  <p><a href="#CIDR-ADDR-HOSTMIN">cidr_addr_hostmin()</a>
                  can fail and set errno for any of the reasons listed for
                  <a href="#CIDR-ADDR-NETWORK">cidr_addr_network()</a>
                  .</p>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-ADDR-NETWORK">
        <span class="funcdef">cidr_addr_network(): Find the network
        address</span>

        <ul>
          <li>Summary:

            <p>Generate a <a href="#CIDR-ADDR">CIDR</a> structure
            describing the network address of the passed-in netblock.</p>

            <p>See the discussion under <a href=
            "#CIDR-ADDR-BROADCAST">cidr_addr_broadcast()</a> concerning
            near- amd maximal-prefix-length blocks for edge case
            details.</p>

            <p>The returned structure should be cleaned up using <a href=
            "#CIDR-FREE">cidr_free()</a> .</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> A <a href="#CIDR-ADDR">CIDR</a> structure
              describing an arbitrary netblock.</li>
            </ul>
          </li>

          <li>Returns:

            <p><a href="#CIDR-ADDR">CIDR</a> *</p>

            <p>Returns a pointer to a <a href="#CIDR-ADDR">CIDR</a>
            structure describing the network address on success. Returns
            NULL on failure.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Given NULL</dd>
                </dl>
              </li>

              <li>
                <div class="note">
                  <p>Note:</p>

                  <p><a href="#CIDR-ADDR-NETWORK">cidr_addr_network()</a>
                  can also fail and set errno for any of the reasons
                  listed for <a href="#CIDR-ALLOC">cidr_alloc()</a> .</p>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-ALLOC">
        <span class="funcdef">cidr_alloc(): Create a <a href=
        "#CIDR-ADDR">CIDR</a></span>

        <ul>
          <li>Summary:

            <p>Allocate memory for a <a href="#CIDR-ADDR">CIDR</a>
            structure and initialize the necessary pieces.</p>

            <p>The returned structure should be cleaned up using <a href=
            "#CIDR-FREE">cidr_free()</a> .</p>

            <p>Note that you should probably never need to call this
            function yourself; you'll generally get your <a href=
            "#CIDR-ADDR">CIDR</a> structures as a return from a function
            like <a href="#CIDR-FROM-STR">cidr_from_str()</a> or <a href=
            "#CIDR-FROM-INADDR">cidr_from_inaddr()</a> .</p>
          </li>

          <li>Arguments:

            <ul>
              <li>None</li>
            </ul>
          </li>

          <li>Returns:

            <p><a href="#CIDR-ADDR">CIDR</a> *</p>

            <p>Returns a pointer to an initialized <a href=
            "#CIDR-ADDR">CIDR</a> structure on success. Returns NULL on
            failure.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>ENOMEM</dt>

                  <dd><em class="funcname">malloc()</em> failed</dd>
                </dl>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-CONTAINS">
        <span class="funcdef">cidr_contains(): Compare netblocks</span>

        <ul>
          <li>Summary:

            <p>This function is passed two <a href="#CIDR-ADDR">CIDR</a>
            structures describing a pair of netblocks. It then determines
            if the latter is wholly contained within the former.</p>

            <p>A common use-case of this will generally involve the second
            "block" actually being a host (/32 or /128) address, as when
            you're implementing ACL's. But that's really just a specific
            case of the second block being any other size; there's nothing
            special or magical about it. As far as libcidr is concerned,
            they're just two netblocks.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * big:</span> The netblock which may (or may not) contain
              the second arg.</li>

              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * little:</span> The netblock which may (or may not) be
              contained within the first arg.</li>
            </ul>
          </li>

          <li>Returns:

            <p>int</p>

            <p>Returns 0 if little is wholly contained within big. Returns
            -1 if it's not, or if an error occured.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>0</dt>

                  <dd>No error (little not in big)</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>EINVAL</dt>

                  <dd>Invalid argument</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>ENOENT</dt>

                  <dd>Internal error (shouldn't happen)</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>EPROTO</dt>

                  <dd>Protocols don't match</dd>
                </dl>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-DUP">
        <span class="funcdef">cidr_dup(): Duplicate a netblock</span>

        <ul>
          <li>Summary:

            <p>Allocate a <a href="#CIDR-ADDR">CIDR</a> , and fill it in
            with a duplicate of the information given.</p>

            <p>The returned structure should be cleaned up using <a href=
            "#CIDR-FREE">cidr_free()</a> .</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * src:</span> A <a href="#CIDR-ADDR">CIDR</a> structure to
              be copied.</li>
            </ul>
          </li>

          <li>Returns:

            <p><a href="#CIDR-ADDR">CIDR</a> *</p>

            <p>Returns a <a href="#CIDR-ADDR">CIDR</a> struct containing a
            copy of src. Returns NULL on failure.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <div class="note">
                  <p>Note:</p>

                  <p><a href="#CIDR-DUP">cidr_dup()</a> can fail and set
                  errno for any of the reasons listed for <a href=
                  "#CIDR-ALLOC">cidr_alloc()</a> .</p>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-EQUALS">
        <span class="funcdef">cidr_equals(): Compare two blocks for
        equality</span>

        <ul>
          <li>Summary:

            <p>This function is passed two <a href="#CIDR-ADDR">CIDR</a>
            structures describing a pair of netblocks. It checks to see if
            they happen to describe the same netblock.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * one:</span> One netblock.</li>

              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * two:</span> Another netblock.</li>
            </ul>
          </li>

          <li>Returns:

            <p>int</p>

            <p>Returns 0 if the two <a href="#CIDR-ADDR">CIDR</a> structs
            describe the same netblock. Returns -1 otherwise.</p>
          </li>
        </ul>
      </li>

      <li id="CIDR-FREE">
        <span class="funcdef">cidr_free(): Free a <a href=
        "#CIDR-ADDR">CIDR</a> structure.</span>

        <ul>
          <li>Summary:

            <p>Takes a <a href="#CIDR-ADDR">CIDR</a> structure and
            <em class="funcname">free()</em> 's all its component
            parts.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef"><a href="#CIDR-ADDR">CIDR</a> *
              tofree:</span> A single <a href="#CIDR-ADDR">CIDR</a>
              structure which has outlived its usefulness.</li>
            </ul>
          </li>

          <li>Returns:

            <p>void</p>
          </li>
        </ul>
      </li>

      <li id="CIDR-FROM-INADDR">
        <span class="funcdef">cidr_from_inaddr(): Parse a struct
        in_addr</span>

        <ul>
          <li>Summary:

            <p>Takes a populated struct in_addr, as you'd get from
            <em class="funcname">accept()</em> or <em class=
            "funcname">getaddrinfo()</em> or similar functions. Parses it
            out and generates a <a href="#CIDR-ADDR">CIDR</a> structure
            based on it. Note that an in_addr only contains a host
            address, so the netmask is initialized to all-1's (/32).</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const struct in_addr *
              uaddr:</span> A populated struct in_addr, from whatever
              source obtained.</li>
            </ul>
          </li>

          <li>Returns:

            <p><a href="#CIDR-ADDR">CIDR</a> *</p>

            <p>Returns a pointer to a populated <a href=
            "#CIDR-ADDR">CIDR</a> containing the address in the passed-in
            struct in_addr. The netmask is initialized to all-1's, and the
            protocol to IPv4. Use <a href="#CIDR-FREE">cidr_free()</a> to
            free the structure when you're finished with it. Returns NULL
            on error.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL</dd>
                </dl>
              </li>

              <li>
                <div class="note">
                  <p>Note:</p>

                  <p><a href="#CIDR-FROM-INADDR">cidr_from_inaddr()</a>
                  can also fail and set errno for any of the reasons
                  listed for <a href="#CIDR-ALLOC">cidr_alloc()</a> .</p>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-FROM-IN6ADDR">
        <span class="funcdef">cidr_from_in6addr(): Parse a struct
        in6_addr</span>

        <ul>
          <li>Summary:

            <p>Takes a populated struct in6_addr, as you'd get from
            <em class="funcname">accept()</em> or <em class=
            "funcname">getaddrinfo()</em> or similar functions. Parses it
            out and generates a <a href="#CIDR-ADDR">CIDR</a> structure
            based on it. Note that a in6_addr only contains a host
            address, so the netmask is initialized to all-1's (/128).</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const struct in6_addr *
              uaddr:</span> A populated struct in6_addr, from whatever
              source obtained.</li>
            </ul>
          </li>

          <li>Returns:

            <p><a href="#CIDR-ADDR">CIDR</a> *</p>

            <p>Returns a pointer to a populated <a href=
            "#CIDR-ADDR">CIDR</a> containing the address in the passed-in
            struct in6_addr. The netmask is initialized to all-1's, and
            the protocol to IPv6 (though it may contain an IPv4-mapped
            address). Use <a href="#CIDR-FREE">cidr_free()</a> to free the
            structure when you're finished with it. Returns NULL on
            error.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL</dd>
                </dl>
              </li>

              <li>
                <div class="note">
                  <p>Note:</p>

                  <p><a href="#CIDR-FROM-INADDR">cidr_from_inaddr()</a>
                  can also fail and set errno for any of the reasons
                  listed for <a href="#CIDR-ALLOC">cidr_alloc()</a> .</p>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-FROM-STR">
        <span class="funcdef">cidr_from_str(): Parse a human-readable
        string</span>

        <ul>
          <li>Summary:

            <p>Takes in a netblock description as a human-readable string,
            and creates a <a href="#CIDR-ADDR">CIDR</a> structure from
            it.</p>

            <p>This is probably the most intricate function in the
            library. It accepts addresses in "address/mask" format.
            'address' is an IP address in valid written form. For IPv4,
            it's 1 through 4 period-separated pieces, expressed in octal,
            hex, or decimal, with the last octet being treated as an 8,
            16, 24, or 32-bit quantity depending on whether there are 4,
            3, 2, or 1 pieces given (respectively). Of course, you're nuts
            for using that flexibility. For IPv6, it's nice and simple; 8
            colon-separated double-octets, excepting that the last 4
            octets can be expressed as a 4-piece dotted-decimal, like an
            IPv4 address (the full flexibility of the IPv4 parsing engine
            is not available, however; intentionally, though that may
            change if necessary). 'mask' can be either a prefix length
            (/0-/32 for IPv4, /0-/128 for IPv6), or a netmask written in
            the standard form for the address family.</p>

            <p>IPv6 addresses can be specified in fully expanded form, or
            with ::-style contraction. IPv4-mapped IPv6 addresses
            (::ffff:a.b.c.d), will be treated as IPv6 addresses. The mask
            can be left off, in which case addresses are treated as host
            addresses (/32 or /128, depending on address family).</p>

            <p>Also, <a href="#CIDR-FROM-STR">cidr_from_str()</a> will
            parse DNS PTR-record-style address formats. That is,
            representations like "4.3.2.1.in-addr.arpa" for IPv4, and an
            extremely long and annoying form ending in .ip6.arpa for IPv6.
            <a href="#CIDR-FROM-STR">cidr_from_str()</a> also understands
            the deprecated RFC1886 form of IPv6 PTR records, which ends in
            .ip6.int, though <a href="#CIDR-TO-STR">cidr_to_str()</a> will
            only generate the current RFC3152-style .ip6.arpa version.
            Note also that while <a href="#CIDR-TO-STR">cidr_to_str()</a>
            treats all addresses as host addresses when building the PTR
            string (ignoring the netmask), <a href=
            "#CIDR-FROM-STR">cidr_from_str()</a> will fill in the netmask
            bits as appropriate for the string given; any octets (or
            half-octets, in the IPv6 form) that are left off the beginning
            will have their netmask bits set to 0.</p>

            <p>It's not the intention of the author that this function
            necessarily be able to decipher any possible address format.
            However, the capabilities given should parse any rational
            address specification, and many irrational ones (like hex/oct
            and collapsed v4 addresses). The intention is rather to
            support the ways the addresses and netmasks are commonly
            written and read, so that a human-readable form can quickly be
            transformed into a format that libcidr can then use in its
            various ways, whether through comparing addresses with
            functions like <a href="#CIDR-CONTAINS">cidr_contains()</a> ,
            or generating references and stats about a netblock with
            functions like <a href=
            "#CIDR-ADDR-BROADCAST">cidr_addr_broadcast()</a> and <a href=
            "#CIDR-NUMHOST">cidr_numhost()</a> , or simply spitting it out
            in different human-readable forms with <a href=
            "#CIDR-TO-STR">cidr_to_str()</a> .</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const char * addr:</span> A string
              containing some human-readable IP block.</li>
            </ul>
          </li>

          <li>Returns:

            <p><a href="#CIDR-ADDR">CIDR</a> *</p>

            <p>Returns a pointer to a populated <a href=
            "#CIDR-ADDR">CIDR</a> describing (hopefully) the block you
            talked about in the string. Use <a href=
            "#CIDR-FREE">cidr_free()</a> to free the structure when you're
            finished with it. Returns NULL on error.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>EINVAL</dt>

                  <dd>Can't parse the input string</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>ENOENT</dt>

                  <dd>Internal error (shouldn't happen)</dd>
                </dl>
              </li>

              <li>
                <div class="note">
                  <p>Note:</p>

                  <p><a href="#CIDR-FROM-STR">cidr_from_str()</a> can also
                  fail and set errno for any of the reasons listed for
                  <a href="#CIDR-ALLOC">cidr_alloc()</a> or <a href=
                  "#CIDR-GET-PFLEN">cidr_get_pflen()</a> .</p>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-GET-ADDR">
        <span class="funcdef">cidr_get_addr(): Return address bits</span>

        <ul>
          <li>Summary:

            <p>Return the address bits which compose the address. This
            should be used in preference to simply referencing inside the
            <a href="#CIDR-ADDR">CIDR</a> manually in external code, since
            the structure might change on you.</p>

            <p>Generally, if you think you need to call this, you should
            probably rethink what you're doing. Most of the time, one of
            the formatted outputs from <a href=
            "#CIDR-TO-STR">cidr_to_str()</a> or one of the manipulation
            functions like <a href=
            "#CIDR-ADDR-HOSTMIN">cidr_addr_hostmin()</a> is what you want.
            Still, there are times when you're interesting in manipulating
            the address by yourself as a bunch of binary bits (the
            cidrcalc example program does this), so this function should
            be used instead of groping around in the structure
            manually.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> An arbitrary netblock.</li>
            </ul>
          </li>

          <li>Returns:

            <p>uint8_t *</p>

            <p>Returns a pointer to an 16-element array of uint8_t's
            representing the address. This array must be <em class=
            "funcname">free()</em> 'd when you're through with it. Returns
            NULL on error.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>ENOMEM</dt>

                  <dd><em class="funcname">malloc()</em> failed</dd>
                </dl>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-GET-MASK">
        <span class="funcdef">cidr_get_mask(): Return netmask bits</span>

        <ul>
          <li>Summary:

            <p>Return the netmask bits which of the given netblock. This
            should be used in preference to simply referencing inside the
            <a href="#CIDR-ADDR">CIDR</a> manually in external code, since
            the structure might change on you.</p>

            <p>See further notes about the desirability of using this
            function above in the notes for <a href=
            "#CIDR-GET-ADDR">cidr_get_addr()</a> .</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> An arbitrary netblock.</li>
            </ul>
          </li>

          <li>Returns:

            <p>uint8_t *</p>

            <p>Returns a pointer to an 16-element array of uint8_t's
            representing the netmask. This array must be <em class=
            "funcname">free()</em> 'd when you're through with it. Returns
            NULL on error.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>ENOMEM</dt>

                  <dd><em class="funcname">malloc()</em> failed</dd>
                </dl>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-GET-PFLEN">
        <span class="funcdef">cidr_get_pflen(): Network bits in the
        netmask</span>

        <ul>
          <li>Summary:

            <p>Poke around the netmask of the passed-in <a href=
            "#CIDR-ADDR">CIDR</a> structure and determine how many bits
            there are in the netmask, as appropriate to the address
            family.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * block:</span> An arbitrary netblock.</li>
            </ul>
          </li>

          <li>Returns:

            <p>int</p>

            <p>Returns the number of network bits in the netmask (0-32 for
            IPv4, 0-128 for IPv6). Returns -1 on error.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>EINVAL</dt>

                  <dd>Invalid (non-contiguous) netmask</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>ENOENT</dt>

                  <dd>Internal error (shouldn't happen)</dd>
                </dl>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-GET-PROTO">
        <span class="funcdef">cidr_get_proto(): Find a netblock's protocol
        family</span>

        <ul>
          <li>Summary:

            <p>Returns the protocol family of an address using one of the
            defined constants. The current choices are CIDR_IPV4 and
            CIDR_IPV6.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> An arbitrary netblock.</li>
            </ul>
          </li>

          <li>Returns:

            <p>int</p>

            <p>Returns the address family of the given netblock.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL</dd>
                </dl>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-IS-V4MAPPED">
        <span class="funcdef">cidr_is_v4mapped(): Is address IPv4-mapped
        IPv6 address?</span>

        <ul>
          <li>Summary:

            <p>An IPv6 address may be in the network range reserved for
            IPv4-mapped addresses. This function will tell you whether it
            is or not. Note that an IPv4 <a href="#CIDR-ADDR">CIDR</a> is
            NOT considered an IPv4-mapped address, and so will return
            failure.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> An arbitrary netblock.</li>
            </ul>
          </li>

          <li>Returns:

            <p>int</p>

            <p>Returns 0 if the address is an IPv4-mapped IPv6 address.
            Returns -1 otherwise.</p>
          </li>
        </ul>
      </li>

      <li id="CIDR-NET-SUBNETS">
        <span class="funcdef">cidr_net_subnets(): Divide a netblock</span>

        <ul>
          <li>Summary:

            <p>Take in a netblock, and derive the two netblocks which it
            divides up into. Return them in an array.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> The netblock to subdivide.</li>
            </ul>
          </li>

          <li>Returns:

            <p><a href="#CIDR-ADDR">CIDR</a> **</p>

            <p>Returns a 2-element array of <a href="#CIDR-ADDR">CIDR</a>
            structs, containing the two subnets of addr. Each of the
            elements should be cleaned up with <a href=
            "#CIDR-FREE">cidr_free()</a> , and the array itself then
            cleaned up with <em class="funcname">free()</em> . Returns
            NULL on failure.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>0</dt>

                  <dd>No error (already a /32 or /128)</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL argument</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>ENOMEM</dt>

                  <dd><em class="funcname">malloc()</em> failed</dd>
                </dl>
              </li>

              <li>
                <div class="note">
                  <p>Note:</p>

                  <p><a href="#CIDR-NET-SUBNETS">cidr_net_subnets()</a>
                  can also fail and set errno for any of the reasons
                  listed for <a href=
                  "#CIDR-ADDR-NETWORK">cidr_addr_network()</a> or <a href=
                  "#CIDR-DUP">cidr_dup()</a> .</p>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-NET-SUPERNET">
        <span class="funcdef">cidr_net_supernet(): Undivide a
        netblock</span>

        <ul>
          <li>Summary:

            <p>Take in a netblock, and derive the parent netblock in which
            it fits.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> The netblock to find the parent of.</li>
            </ul>
          </li>

          <li>Returns:

            <p><a href="#CIDR-ADDR">CIDR</a> *</p>

            <p>Returns a <a href="#CIDR-ADDR">CIDR</a> struct defining the
            parent network of addr. Clean this up with <a href=
            "#CIDR-FREE">cidr_free()</a> when you're finished with it.
            Returns NULL on failure.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>0</dt>

                  <dd>No error (already a /0)</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL argument</dd>
                </dl>
              </li>

              <li>
                <div class="note">
                  <p>Note:</p>

                  <p><a href="#CIDR-NET-SUPERNET">cidr_net_supernet()</a>
                  can also fail and set errno for any of the reasons
                  listed for <a href="#CIDR-DUP">cidr_dup()</a> .</p>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-NUMADDR">
        <span class="funcdef">cidr_numaddr(): Addresses in a
        netblock</span>

        <ul>
          <li>Summary:

            <p>Determine the total number of addresses in a netblock
            (including the network and broadcast addresses).</p>

            <p>This function returns a pointer to a pre-formatted string
            because we're potentially returning a value up to 2**128. I
            don't feel like trying to portably do 128-bit arithmetic. Do
            you?</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> An arbitrary netblock.</li>
            </ul>
          </li>

          <li>Returns:

            <p>const char *</p>

            <p>Returns a pointer to a string containing the number of
            addresses in the netblock. Note that this is a static string;
            it should not be overwritten, and doesn't need to be
            <em class="funcname">free()</em> 'd. Make a copy if you want
            to manipulate it. Returns NULL on error.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL</dd>
                </dl>
              </li>

              <li>
                <div class="note">
                  <p>Note:</p>

                  <p><a href="#CIDR-NUMADDR">cidr_numaddr()</a> can also
                  also fail and set errno for any of the reasons listed
                  for <a href=
                  "#CIDR-NUMADDR-PFLEN">cidr_numaddr_pflen()</a> .</p>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-NUMADDR-PFLEN">
        <span class="funcdef">cidr_numaddr_pflen(): Addresses in a prefix
        length</span>

        <ul>
          <li>Summary:

            <p>Determine the total number of addresses in a netblock with
            the given prefix length (including the network and broadcast
            addresses).</p>

            <p>Note that this takes an IPv6 prefix length; that is, 0-128.
            If you're interested in an IPv4 address with a given prefix
            length, add 96 to it when you call this function.</p>

            <p>See the note in <a href="#CIDR-NUMADDR">cidr_numaddr()</a>
            for why we're returning a string and not a number.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">int pflen:</span> A prefix length
              (0-128).</li>
            </ul>
          </li>

          <li>Returns:

            <p>const char *</p>

            <p>Returns a pointer to a string containing the number of
            addresses in the netblock. Note that this is a static string;
            it should not be overwritten, and doesn't need to be
            <em class="funcname">free()</em> 'd. Make a copy if you want
            to manipulate it. Returns NULL on error.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EINVAL</dt>

                  <dd>Invalid prefix length</dd>
                </dl>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-NUMHOST">
        <span class="funcdef">cidr_numhost(): Host addresses in a
        netblock</span>

        <ul>
          <li>Summary:

            <p>Determine the total number of host addresses in a netblock
            (excluding the network and broadcast addresses).</p>

            <p>See the note in <a href="#CIDR-NUMADDR">cidr_numaddr()</a>
            for why we're returning a string and not a number.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> An arbitrary netblock.</li>
            </ul>
          </li>

          <li>Returns:

            <p>const char *</p>

            <p>Returns a pointer to a string containing the number of host
            addresses in the netblock. Note that this is a static string;
            it should not be overwritten, and doesn't need to be
            <em class="funcname">free()</em> 'd. Make a copy if you want
            to manipulate it. Returns NULL on error.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL</dd>
                </dl>
              </li>

              <li>
                <div class="note">
                  <p>Note:</p>

                  <p><a href="#CIDR-NUMHOST">cidr_numhost()</a> can also
                  also fail and set errno for any of the reasons listed
                  for <a href=
                  "#CIDR-NUMHOST-PFLEN">cidr_numhost_pflen()</a> .</p>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-NUMHOST-PFLEN">
        <span class="funcdef">cidr_numhost_pflen(): Host addresses in a
        prefix length</span>

        <ul>
          <li>Summary:

            <p>Determine the total number of host addresses in a netblock
            with the given prefix length (excluding the network and
            broadcast addresses).</p>

            <p>Note that this takes an IPv6 prefix length; that is, 0-128.
            If you're interested in an IPv4 address with a given prefix
            length, add 96 to it when you call this function.</p>

            <p>See the note in <a href="#CIDR-NUMADDR">cidr_numaddr()</a>
            for why we're returning a string and not a number.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">int pflen:</span> A prefix length
              (0-128).</li>
            </ul>
          </li>

          <li>Returns:

            <p>const char *</p>

            <p>Returns a pointer to a string containing the number of host
            addresses in the netblock. Note that this is a static string;
            it should not be overwritten, and doesn't need to be
            <em class="funcname">free()</em> 'd. Make a copy if you want
            to manipulate it. Returns NULL on error.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EINVAL</dt>

                  <dd>Invalid prefix length</dd>
                </dl>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-TO-INADDR">
        <span class="funcdef">cidr_to_inaddr(): Create a struct
        in_addr</span>

        <ul>
          <li>Summary:

            <p>Takes in a <a href="#CIDR-ADDR">CIDR</a> and creates a
            struct in_addr from it. This struct can then be used in
            <em class="funcname">connect()</em> or similar network-related
            functions. If the users passes in a struct in_addr, it will be
            filled in. Otherwise, one will be allocated and returned.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> A <a href="#CIDR-ADDR">CIDR</a> structure
              describing the host to be translated into a struct in_addr.
              Note that the netmask is irrelevant and will be ignored.
              <a href="#CIDR-TO-INADDR">cidr_to_inaddr()</a> supports only
              IPv4 addresses, as the underlying structure only does.</li>

              <li><span class="argdef">struct in_addr * uptr:</span> A
              pointer to a pre-allocated struct in_addr, or NULL. If
              non-NULL, the pointed-at structure will be filled in. If
              NULL, a new structure will be allocated, filled in, and
              returned.</li>
            </ul>
          </li>

          <li>Returns:

            <p>struct in_addr *</p>

            <p>Returns a pointer to the filled-in struct in_addr. If the
            user passed one in, this will just point to the same place and
            can profitably be ignored. If the user passed in NULL, this
            will point to the struct in_addr we allocated, which should be
            <em class="funcname">free()</em> 'd by the user when they're
            finished with it. Returns NULL on error.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>ENOMEM</dt>

                  <dd><em class="funcname">malloc()</em> failed</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>EPROTOTYPE</dt>

                  <dd>Bad protocol type (must be IPv4)</dd>
                </dl>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-TO-IN6ADDR">
        <span class="funcdef">cidr_to_in6addr(): Create a struct
        in6_addr</span>

        <ul>
          <li>Summary:

            <p>Takes in a <a href="#CIDR-ADDR">CIDR</a> and creates a
            struct in6_addr from it. This struct can then be used in
            <em class="funcname">connect()</em> or similar network-related
            functions. If the users passes in a struct in6_addr, it will
            be filled in. Otherwise, one will be allocated and
            returned.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * addr:</span> A <a href="#CIDR-ADDR">CIDR</a> structure
              describing the host to be translated into a struct in6_addr.
              Note that the netmask is irrelevant and will be ignored.
              <a href="#CIDR-TO-IN6ADDR">cidr_to_in6addr()</a> supports
              both IPv4 and IPv6 addresses, as the underlying structure
              does as well. IPv4 addresses are treated as v4-mapped IPv6
              addresses.</li>

              <li><span class="argdef">struct in6_addr * uptr:</span> A
              pointer to a pre-allocated struct in6_addr, or NULL. If
              non-NULL, the pointed-at structure will be filled in. If
              NULL, a new structure will be allocated, filled in, and
              returned.</li>
            </ul>
          </li>

          <li>Returns:

            <p>struct in6_addr *</p>

            <p>Returns a pointer to the filled-in struct in6_addr. If the
            user passed one in, this will just point to the same place and
            can profitably be ignored. If the user passed in NULL, this
            will point to the struct in6_addr we allocated, which should
            be <em class="funcname">free()</em> 'd by the user when
            they're finished with it. Returns NULL on error.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EFAULT</dt>

                  <dd>Passed NULL</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>ENOMEM</dt>

                  <dd><em class="funcname">malloc()</em> failed</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>EPROTOTYPE</dt>

                  <dd>Bad protocol type (must be IPv4 or IPv6)</dd>
                </dl>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-TO-STR">
        <span class="funcdef">cidr_to_str(): Create a human-readable
        netblock description</span>

        <ul>
          <li>Summary:

            <p>Takes in a <a href="#CIDR-ADDR">CIDR</a> structure, and
            generates up a human-readable string describing the netblock.
            This function has a lot of flexibility, depending on the flags
            passed to it. The default output is "address/pflen" form, with
            the address in a reasonably compact form, and the prefix
            length given numerically. Flags alter the output in various
            ways, and are set as bitmasks, so they can be combined however
            you wish. They can be used in any combination that makes
            sense, and a large number of combinations that don't.</p>

            <p>The current flags are:<br>
            CIDR_NOFLAGS: A stand-in for when you just want the default
            output<br>
            CIDR_NOCOMPACT: Don't do ::-style IPv6 compaction<br>
            CIDR_VERBOSE: Show leading 0's in octets [v6 only]<br>
            CIDR_USEV6: Use IPv4-mapped address form for IPv4 addresses
            (::ffff:a.b.c.d)<br>
            CIDR_USEV4COMPAT: Use IPv4-compat form (::a.b.c.d) instead of
            IPv4-mapped form (only meaningful in combination with
            CIDR_USEV6)<br>
            CIDR_NETMASK: Return a netmask in standard form after the
            slash, instead of the prefix length. Note that the form of the
            netmask can thus be altered by the various flags that alter
            how the address is displayed.<br>
            CIDR_ONLYADDR: Show only the address, without the
            prefix/netmask<br>
            CIDR_ONLYPFLEN: Show only the prefix length (or netmask, when
            combined with CIDR_NETMASK), without the address.<br>
            CIDR_WILDCARD: Show a Cisco-style wildcard mask instead of the
            netmask (only meaningful in combination with CIDR_NETMASK)<br>
            CIDR_FORCEV6: Forces treating the <a href=
            "#CIDR-ADDR">CIDR</a> as an IPv6 address, no matter what it
            really is. This doesn't do any conversion or translation; just
            treats the raw data as if it were IPv6.<br>
            CIDR_FORCEV4: Forces treating the <a href=
            "#CIDR-ADDR">CIDR</a> as an IPv4 address, no matter what it
            really is. This doesn't do any conversion or translation; just
            treats the raw data as if it were IPv4.<br>
            CIDR_REVERSE: Generates a .in-addr.arpa or .ip6.arpa-style PTR
            record name for the given block. Note that this always treats
            it solely as an address; the netmask is ignored. See some
            notes in <a href="#CIDR-FROM-STR">cidr_from_str()</a> for
            details of the asymmetric treatment of this form of address
            representation relating to the netmask.</p>

            <p>Many combinations can give somewhat surprising results, but
            they should allow any of a host of manipulations to output
            just the data you might be interested in. The "mkstr" test
            program in the source tree is extremely useful for manual
            testing of the various flags to see visually what they do, and
            is a lot quicker than trying to code them all to test it out.
            Use it to your advantage.</p>
          </li>

          <li>Arguments:

            <ul>
              <li><span class="argdef">const <a href="#CIDR-ADDR">CIDR</a>
              * block:</span> The <a href="#CIDR-ADDR">CIDR</a> structure
              to generate a string form of. The address family will be
              autodetected.</li>

              <li><span class="argdef">int flags:</span> A bitmask of the
              various possible flags the function accepts.</li>
            </ul>
          </li>

          <li>Returns:

            <p>char *</p>

            <p>Returns a pointer to a string containing the representation
            of the network. Be sure to <em class="funcname">free()</em> it
            when you're finished.</p>
          </li>

          <li>Error codes:

            <ul>
              <li>
                <dl>
                  <dt>EINVAL</dt>

                  <dd>Invalid argument (bad block or flags)</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>ENOENT</dt>

                  <dd>Internal error (shouldn't happen)</dd>
                </dl>
              </li>

              <li>
                <dl>
                  <dt>ENOMEM</dt>

                  <dd><em class="funcname">malloc()</em> failed</dd>
                </dl>
              </li>

              <li>
                <div class="note">
                  <p>Note:</p>

                  <p><a href="#CIDR-TO-STR">cidr_to_str()</a> can also
                  fail and set errno for any of the reasons listed for
                  <a href="#CIDR-ALLOC">cidr_alloc()</a> or <a href=
                  "#CIDR-GET-PFLEN">cidr_get_pflen()</a> .</p>
                </div>
              </li>
            </ul>
          </li>
        </ul>
      </li>

      <li id="CIDR-VERSION">
        <span class="funcdef">cidr_version(): Library version</span>

        <ul>
          <li>Summary:

            <p>Returns a static string describing the library release
            version.</p>
          </li>

          <li>Arguments:

            <ul>
              <li>None</li>
            </ul>
          </li>

          <li>Returns:

            <p>const char *</p>

            <p>Returns a pointer to a static string describing the library
            version number. It shouldn't be overwritten or <em class=
            "funcname">free()</em> 'd.</p>
          </li>
        </ul>
      </li>
    </ul>
  </div>
</body>
</html>
